\begin{introduction}
	\item 单子
	\item 单子的包装和析出
	\item 单子绑定
\end{introduction}

\section{单子}

\subsection{单子的引入}

AutoScript 中，\textbf{单子（Monad）}是对拥有特定特征的类型的称呼。首先让我们看看下面的一些例子：

\begin{lstlisting}
const make_option = func (x : T) -> Some x;
const make_list = func (x : T) -> Vector[x];

const main = func () -> do {
	auto opt = make_option(42);				// 创建对象
	match (opt)
		Some x -> print x;					// 取出内部的对象
		Null -> print "Null object";		// 空对象的情形
	
	auto list = make_list(42);
	if (not list.empty()) {
		match (list)
			(x) -> print x;
			() -> print "Empty list";
	}
};
\end{lstlisting}

在上面的例子中，我们分别对于 \lstinline!Option! 和 \lstinline!List! 两种类型展示了一些常见的使用代码。注释中已经给出了这些行为的总结：

\begin{itemize}
	\item 包装：这些类型需要一个包装函数。
	\item 对象取出：在对象非空的情况下，需要取出其中的对象。
\end{itemize}

接收对象并返回同类型对象的包装是一种常见的设计 \footnote{这个例子中，我们的函数 \lstinline!iterate! 可能会遇到非法输入，因此可能返回 \lstinline!Null!。}：

\begin{lstlisting}
const iterate = func (x : Int) -> do {
	if (x <= 0) {
		return Null as Option Int;
	}
	return x `mod` 2 == 0 and x / 2 or x + 1;
};

const main = func () -> do {
	scan x : mut Int;
	for (i from range(1, 100)) {
		match (iterate(x))
			Some y -> x <- y,
			Null -> break;
	}
	print x;
};
\end{lstlisting}

这也就是第三种常见的操作：函数组合。理想情况下，我们能让返回上面这些类型的函数组合更加方便，比如声明函数组合运算符 \lstinline!<< : (T -> M T) -> (T -> M T) -> T -> M T!，其中 \lstinline!M! 是一个类型函数（这里实际上是一个模版）。然而，AutoScript 并不像 Haskell 那样拥有内置的高阶范型，也不像 C++ 拥有模版模版参数，我们只能为此设置一个新的机制 \footnote{AutoScript 中的大部分实体都可以三元地分类为对象、函数和类型；因此所谓的“高阶类型”本身也只是一个返回类型的函数罢了。}，这就是基于 ADT 的单子类型。 \\

单子定义为任何用 \lstinline!@monad! 属性修饰的 ADT，它包含了一个“数据类型”，即包装实际数据的标签和一个“空类型”，用来代表数据不存在的情况。以 \lstinline!Option! 为例：

\begin{lstlisting}
@monad(option_bind)
const Option = data (Some T | Null);

const option_bind = func (opt : Option[T]) -> func (f : T -> Option[T]) -> match (opt)
	Some x -> f(x)
	Null -> Null;

@monad
const NotMonad = data (A Int);		// 编译错误：标签个数不等于 2
\end{lstlisting}

编译器会将第一个出现的标签作为单子的数据类型，第二个作为空类型。上面在 \lstinline!@monad! 属性中出现的是指定的函数组合函数，它的签名是确定的因此不需要提前声明。

\subsection{monad 表达式}

AutoScript 为了让上一节中提到的语法糖生效，特地设计了 \lstinline!monad! 表达式。在 \lstinline!monad! 表达式中，许多表达式的含义会发生变化。让我们以 \lstinline!monad Option! 为例：

\begin{lstlisting}
const main = func () -> do {
	auto res = monad Option {
		scan x : mut Option[Int];
		if (x <= 0) {		// if 中的判断表达式会对 x 进行拆包，如果是 Null 则不做任何事情
			return 42;		// 返回的实际是 Option 42
		}
		x <- x + 1;			// 对 x 进行拆包且不为 Null 才进行操作。
		return x;			// 返回的实际是 Option x
	};
	print res;
};
\end{lstlisting}

上面，无论是在 \lstinline!x <= 0! 的判断处、\lstinline!x + 1! 的运算处，还是返回语句，编译器都为这些操作添加了额外的判断。我们实际上可以写出下面的等价代码：

\begin{lstlisting}
const main = func () -> do {
	auto res = do {
		scan x : mut Option[Int];
		match (x)
			Null -> break;
			Some y -> if (y <= 0) { return Option 42; };
		match (x)
			Null -> break;
			Some y -> x <- Option (x + 1);
		return Option x;
	};
	print res;
};
\end{lstlisting}

实际上，除了原子表达式和初始化表达式，其它的\emph{所有}表达式都会经过拆箱和装箱处理。 \\

\lstinline!monad! 表达式中虽然允许出现多种单子类型，但其返回类型必须是唯一可以确定的，这点和 \lstinline!do! 表达式没有不同。

\begin{lstlisting}
const main = func () -> do {
	auto res = monad Option {
		scan b : Bool;
		if (b) {
			return 42;		// 编译器推断 monad 表达式返回类型为 Option[Int]
		}
		return "abc";		// 编译错误，表达式类型前后判断矛盾
	};
};
\end{lstlisting}

有时，我们并不需要编译器自动将表达式包装为单子类型，此时可以使用表达式修饰符 \lstinline!fixed! 来令某一层表达式不受单子包装影响。

\begin{lstlisting}
const main = func () -> do {
	auto res = monad Option {
		scan x : Int;
		if (fixed x <= 0) {		// 也可以让 x 保持 Int 类型
			x <- fixed 42;		// 由于左侧是 Int 类型，右侧不需要包装为 Some 42
		}
		return x;
	};
};
\end{lstlisting}

\lstinline!fixed! 只能作用于一次表达式求值。如果需要嵌套的多个表达式都不受单子装箱影响，可以直接使用 \lstinline!do! 表达式。

\begin{lstlisting}
const main = func () -> do {
	auto res = monad Option {
		scan x : Int;
		if (fixed x <= 0) {
			x <- fixed do { return x * x + 1; };	// 等效于 fixed (fixed x * x) + 1
		}
		return x;
	};
};
\end{lstlisting}

嵌套的多个 \lstinline!monad! 和 \lstinline!do! 语句相互独立，不会受到单子声明影响，这也是为什么上面的代码中 \lstinline!do! 的语句块屏蔽了外层语句块的装箱操作。不过，\lstinline!do! 表达式本身是一个表达式，因此它的返回值会被装箱为 \lstinline!Option! 类型，因此上例中我在最外层使用了 \lstinline!fixed! 修饰符。

\subsection{单子捕获}

从前面的例子我们看到，当单子中不存在对象时，默认的行为是跳过执行语句。不过，我们可以通过 \lstinline!catch! 子句将这些情况捕捉。我们此前曾经提到过 \lstinline!catch! 子句用于处理表达式的异常类型；实际上，异常类型的本质就是单子的空类型，我们很快就会提到它。

\begin{lstlisting}
const f = func () -> return Some 42;

const main = func () -> do {
	print f() catch Null -> "Null option";
};
\end{lstlisting}



\section{异常抛出和捕获}

AutoScript 中的异常处理是一个用于处理程序错误状态的机制。当程序遇到一个意料之外的状况时，可以通过 \lstinline!throw! 语句抛出一个异常。这个异常会顺着函数的调用链一层层回溯，直到跳出 \lstinline!main! 函数后终止程序。

\begin{lstlisting}
const main = func () -> do {
	const f = func () -> throw 42;
	f();					// f 抛出一个异常 42，随后其再次被 main 函数抛出，程序终止
};
\end{lstlisting}

如果不希望异常继续回溯，可以在可能产生异常的表达式中使用 \lstinline!catch! 子句。它的用法和 \lstinline!match! 子句几乎完全相同。

\begin{grammar}
\begin{enumerate}
	\item \lstinline!catch ([id]) [func-expr-list]!
	\item \lstinline!catch [func-expr-list]!
	\item \lstinline!catch!
\end{enumerate}
\end{grammar}

上面的第一种相当于为捕获的异常类型声明了一个变量，在捕获时会优先将异常对象初始化到这个变量上。第二种则忽略了异常对象的整体值。第三种直接忽略所有捕获的异常。

\begin{lstlisting}
const throwable = func () -> do {
	scan x : Int;
	if (x < 0) {
		throw (x, 0);
	}
	else if (x > 0) {
		throw (0, x);
	}
	else {
		throw (0, 0);
	}
};

const main = func () -> do {
	throwable() catch
		? (0, 0) -> print "Zero",
		? (x, 0) -> print "Negative",
		? (0, x) -> print "Positive";
};
\end{lstlisting}

一些情况下，我们可能希望将捕获的异常再次抛出。此时只需要使用 \lstinline!throw;! 即可。

\begin{lstlisting}
const ErrorType = data (FatalError | NormalError);

const f = func () -> do {
	scan x : Int;
	if (x < 0) {
		throw FatalError;
	}
	throw NormalError;
};

const main = func () -> do {
	f() catch
		NormalError -> print "It's fine";
		FatalError -> throw;
};
\end{lstlisting}

\section{异常类型}

\subsection{异常类型推断}

在表达式章节中我们曾经介绍过表达式的异常类型。这一章中让我们详细介绍这个特性。首先，\lstinline!throw [expr]! 语句本身虽然类型为 \lstinline!Void!，但其拥有异常类型 \lstinline!typeof([expr])!。随后，所有包含 \lstinline!throw! 语句的 \lstinline!do! 表达式和 \lstinline!monad! 表达式都会将其中的 \lstinline!throw! 语句纳入自身异常类型的考量范围。

\begin{lstlisting}
const f = func () -> do {
	scan x : Int;
	if (x < 0) {
		throw 42;		// 异常类型为 Int
	}
	else if (x > 0) {
		throw "abc";	// 异常类型为 String
	}
	else {
		throw True;		// 异常类型为 Bool
	}
};						// do 表达式的异常类型为 Int | String | Bool
\end{lstlisting}

除了参考 \lstinline!throw! 语句的异常类型，任何表达式的异常类型都会参与到编译器的判断中。比如内置的除法运算会产生 \lstinline!ZeroDivisor! 异常，因此包含除法的表达式拥有异常类型 \lstinline!ZeroDivisor!。

\begin{lstlisting}
const f = func () -> do {
	scan x : Int;
	scan y : Int;
	print x / y;		// 异常类型为 ZeroDivisor
};						// 异常类型为 ZeroDivisor
\end{lstlisting}

当然，如果在可能产生异常的语句处使用 \lstinline!catch! 子句，且不再次抛出，则这个语句不参与编译器的异常类型推断。

\begin{lstlisting}
const f = func () -> do {
	scan x : Int;
	scan y : Int;
	print x / y catch;	// 异常类型为 Void
};						// 异常类型为 Void
\end{lstlisting}

\subsection{函数的异常类型声明}

异常类型声明出现在函数类型的最后，用关键字 \lstinline!except! 表示。

\begin{grammar}[异常类型声明] \label{grm:exception-type-declaration}
\begin{enumerate}
	\item \lstinline!except [type]!
	\item \lstinline!except!
\end{enumerate}
\end{grammar}

第一种是显示给出所有可能的抛出类型，第二种则仅声明函数会产生异常，并委托编译器通过函数定义来推断具体的异常类型。后者是更加常用的形式。函数异常声明中出现的类型应该是函数定义中异常类型的超集。

\begin{lstlisting}
const f : Int -> Void except Int | String;
const f = x -> throw 42;					// 没问题
\end{lstlisting}


\section{标准库中的异常类型}

本节让我们介绍一些标准库中的异常类型，我们在编写自己的代码时，也完全可以复用这些类型。

\subsection{BasicException}

\lstinline!Prelude.BasicException! 是一个最基本的异常类型。

\begin{lstlisting}
const BasicException = struct (msg : String);
\end{lstlisting}


\subsection{InvalidIndex}

\lstinline!Prelude.InvalidIndex! 常见于各种线性容器类型。

\begin{lstlisting}
const InvalidIndex = struct (msg : String, idx : Int);
\end{lstlisting}
